/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Inventory Management System
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost:9091".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        } else {
            this.configuration = {} as any;
            this.basePath = this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface CategoryDto
 */
export interface CategoryDto {
    /**
     * 
     * @type {Date}
     * @memberof CategoryDto
     */
    createdAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof CategoryDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryDto
     */
    name?: string;
    /**
     * 
     * @type {CategoryDto}
     * @memberof CategoryDto
     */
    parentCategory?: CategoryDto;
    /**
     * 
     * @type {Array<ProductDto>}
     * @memberof CategoryDto
     */
    products?: Array<ProductDto>;
    /**
     * 
     * @type {Array<CategoryDto>}
     * @memberof CategoryDto
     */
    subCategories?: Array<CategoryDto>;
    /**
     * 
     * @type {SupplierDto}
     * @memberof CategoryDto
     */
    supplier?: SupplierDto;
    /**
     * 
     * @type {Date}
     * @memberof CategoryDto
     */
    updatedAt?: Date;
}

/**
 * 
 * @export
 * @interface CustomerDto
 */
export interface CustomerDto {
    /**
     * 
     * @type {string}
     * @memberof CustomerDto
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerDto
     */
    code?: string;
    /**
     * 
     * @type {Date}
     * @memberof CustomerDto
     */
    createdAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof CustomerDto
     */
    email?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerDto
     */
    id?: number;
    /**
     * 
     * @type {Array<MovementDto>}
     * @memberof CustomerDto
     */
    movements?: Array<MovementDto>;
    /**
     * 
     * @type {string}
     * @memberof CustomerDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerDto
     */
    phone?: string;
    /**
     * 
     * @type {Date}
     * @memberof CustomerDto
     */
    updatedAt?: Date;
}

/**
 * 
 * @export
 * @interface MovementDetailDto
 */
export interface MovementDetailDto {
    /**
     * 
     * @type {Date}
     * @memberof MovementDetailDto
     */
    createdAt?: Date;
    /**
     * 
     * @type {number}
     * @memberof MovementDetailDto
     */
    id?: number;
    /**
     * 
     * @type {MovementDto}
     * @memberof MovementDetailDto
     */
    movement?: MovementDto;
    /**
     * 
     * @type {ProductDto}
     * @memberof MovementDetailDto
     */
    product?: ProductDto;
    /**
     * 
     * @type {number}
     * @memberof MovementDetailDto
     */
    quantity?: number;
    /**
     * 
     * @type {ProductRepositoryDto}
     * @memberof MovementDetailDto
     */
    sourceProductRepository?: ProductRepositoryDto;
    /**
     * 
     * @type {ProductRepositoryDto}
     * @memberof MovementDetailDto
     */
    targetProductRepository?: ProductRepositoryDto;
    /**
     * 
     * @type {Date}
     * @memberof MovementDetailDto
     */
    updatedAt?: Date;
    /**
     * 
     * @type {number}
     * @memberof MovementDetailDto
     */
    value?: number;
}

/**
 * 
 * @export
 * @interface MovementDto
 */
export interface MovementDto {
    /**
     * 
     * @type {Array<MovementDto>}
     * @memberof MovementDto
     */
    childrenMovement?: Array<MovementDto>;
    /**
     * 
     * @type {string}
     * @memberof MovementDto
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof MovementDto
     */
    comments?: string;
    /**
     * 
     * @type {Date}
     * @memberof MovementDto
     */
    createdAt?: Date;
    /**
     * 
     * @type {CustomerDto}
     * @memberof MovementDto
     */
    customer?: CustomerDto;
    /**
     * 
     * @type {number}
     * @memberof MovementDto
     */
    id?: number;
    /**
     * 
     * @type {MovementDto}
     * @memberof MovementDto
     */
    movement?: MovementDto;
    /**
     * 
     * @type {Date}
     * @memberof MovementDto
     */
    movementDate?: Date;
    /**
     * 
     * @type {Array<MovementDetailDto>}
     * @memberof MovementDto
     */
    movementDetails?: Array<MovementDetailDto>;
    /**
     * 
     * @type {MovementTypeDto}
     * @memberof MovementDto
     */
    movementType?: MovementTypeDto;
    /**
     * 
     * @type {SupplierDto}
     * @memberof MovementDto
     */
    supplier?: SupplierDto;
    /**
     * 
     * @type {number}
     * @memberof MovementDto
     */
    totalValue?: number;
    /**
     * 
     * @type {number}
     * @memberof MovementDto
     */
    type?: number;
    /**
     * 
     * @type {Date}
     * @memberof MovementDto
     */
    updatedAt?: Date;
}

/**
 * 
 * @export
 * @interface MovementTypeDto
 */
export interface MovementTypeDto {
    /**
     * 
     * @type {Date}
     * @memberof MovementTypeDto
     */
    createdAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof MovementTypeDto
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof MovementTypeDto
     */
    id?: number;
    /**
     * 
     * @type {Array<MovementDto>}
     * @memberof MovementTypeDto
     */
    movements?: Array<MovementDto>;
    /**
     * 
     * @type {string}
     * @memberof MovementTypeDto
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MovementTypeDto
     */
    parentMovementRequired?: boolean;
    /**
     * 
     * @type {RepositoryDto}
     * @memberof MovementTypeDto
     */
    sourceRepository?: RepositoryDto;
    /**
     * 
     * @type {RepositoryDto}
     * @memberof MovementTypeDto
     */
    targetRepository?: RepositoryDto;
    /**
     * 
     * @type {Date}
     * @memberof MovementTypeDto
     */
    updatedAt?: Date;
}

/**
 * 
 * @export
 * @interface ProductDto
 */
export interface ProductDto {
    /**
     * 
     * @type {CategoryDto}
     * @memberof ProductDto
     */
    category?: CategoryDto;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    code?: string;
    /**
     * 
     * @type {Date}
     * @memberof ProductDto
     */
    createdAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    id?: number;
    /**
     * 
     * @type {Array<MovementDetailDto>}
     * @memberof ProductDto
     */
    movementDetails?: Array<MovementDetailDto>;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    photo?: string;
    /**
     * 
     * @type {Array<ProductRepositoryDto>}
     * @memberof ProductDto
     */
    productRepositories?: Array<ProductRepositoryDto>;
    /**
     * 
     * @type {SupplierDto}
     * @memberof ProductDto
     */
    supplier?: SupplierDto;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    unitType?: number;
    /**
     * 
     * @type {Date}
     * @memberof ProductDto
     */
    updatedAt?: Date;
}

/**
 * 
 * @export
 * @interface ProductRepositoryDto
 */
export interface ProductRepositoryDto {
    /**
     * 
     * @type {Date}
     * @memberof ProductRepositoryDto
     */
    createdAt?: Date;
    /**
     * 
     * @type {number}
     * @memberof ProductRepositoryDto
     */
    currentQuantity?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductRepositoryDto
     */
    id?: number;
    /**
     * 
     * @type {Array<MovementDetailDto>}
     * @memberof ProductRepositoryDto
     */
    negativeMovements?: Array<MovementDetailDto>;
    /**
     * 
     * @type {Array<MovementDetailDto>}
     * @memberof ProductRepositoryDto
     */
    positiveMovements?: Array<MovementDetailDto>;
    /**
     * 
     * @type {number}
     * @memberof ProductRepositoryDto
     */
    price?: number;
    /**
     * 
     * @type {ProductDto}
     * @memberof ProductRepositoryDto
     */
    product?: ProductDto;
    /**
     * 
     * @type {RepositoryDto}
     * @memberof ProductRepositoryDto
     */
    repository?: RepositoryDto;
    /**
     * 
     * @type {Date}
     * @memberof ProductRepositoryDto
     */
    updatedAt?: Date;
}

/**
 * 
 * @export
 * @interface RepositoryDto
 */
export interface RepositoryDto {
    /**
     * 
     * @type {Date}
     * @memberof RepositoryDto
     */
    createdAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof RepositoryDto
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RepositoryDto
     */
    external?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RepositoryDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RepositoryDto
     */
    name?: string;
    /**
     * 
     * @type {Array<ProductRepositoryDto>}
     * @memberof RepositoryDto
     */
    productRepositories?: Array<ProductRepositoryDto>;
    /**
     * 
     * @type {Array<MovementTypeDto>}
     * @memberof RepositoryDto
     */
    sourceMovementTypes?: Array<MovementTypeDto>;
    /**
     * 
     * @type {Array<MovementTypeDto>}
     * @memberof RepositoryDto
     */
    targetMovementTypes?: Array<MovementTypeDto>;
    /**
     * 
     * @type {Date}
     * @memberof RepositoryDto
     */
    updatedAt?: Date;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalCategoryDto
 */
export interface ResponseCanonicalCategoryDto {
    /**
     * 
     * @type {CategoryDto}
     * @memberof ResponseCanonicalCategoryDto
     */
    response?: CategoryDto;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalCategoryDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalCustomerDto
 */
export interface ResponseCanonicalCustomerDto {
    /**
     * 
     * @type {CustomerDto}
     * @memberof ResponseCanonicalCustomerDto
     */
    response?: CustomerDto;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalCustomerDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalListCategoryDto
 */
export interface ResponseCanonicalListCategoryDto {
    /**
     * 
     * @type {Array<CategoryDto>}
     * @memberof ResponseCanonicalListCategoryDto
     */
    response?: Array<CategoryDto>;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalListCategoryDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalListCustomerDto
 */
export interface ResponseCanonicalListCustomerDto {
    /**
     * 
     * @type {Array<CustomerDto>}
     * @memberof ResponseCanonicalListCustomerDto
     */
    response?: Array<CustomerDto>;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalListCustomerDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalListMovementDetailDto
 */
export interface ResponseCanonicalListMovementDetailDto {
    /**
     * 
     * @type {Array<MovementDetailDto>}
     * @memberof ResponseCanonicalListMovementDetailDto
     */
    response?: Array<MovementDetailDto>;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalListMovementDetailDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalListMovementDto
 */
export interface ResponseCanonicalListMovementDto {
    /**
     * 
     * @type {Array<MovementDto>}
     * @memberof ResponseCanonicalListMovementDto
     */
    response?: Array<MovementDto>;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalListMovementDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalListMovementTypeDto
 */
export interface ResponseCanonicalListMovementTypeDto {
    /**
     * 
     * @type {Array<MovementTypeDto>}
     * @memberof ResponseCanonicalListMovementTypeDto
     */
    response?: Array<MovementTypeDto>;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalListMovementTypeDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalListProductDto
 */
export interface ResponseCanonicalListProductDto {
    /**
     * 
     * @type {Array<ProductDto>}
     * @memberof ResponseCanonicalListProductDto
     */
    response?: Array<ProductDto>;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalListProductDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalListProductRepositoryDto
 */
export interface ResponseCanonicalListProductRepositoryDto {
    /**
     * 
     * @type {Array<ProductRepositoryDto>}
     * @memberof ResponseCanonicalListProductRepositoryDto
     */
    response?: Array<ProductRepositoryDto>;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalListProductRepositoryDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalListRepositoryDto
 */
export interface ResponseCanonicalListRepositoryDto {
    /**
     * 
     * @type {Array<RepositoryDto>}
     * @memberof ResponseCanonicalListRepositoryDto
     */
    response?: Array<RepositoryDto>;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalListRepositoryDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalListSupplierDto
 */
export interface ResponseCanonicalListSupplierDto {
    /**
     * 
     * @type {Array<SupplierDto>}
     * @memberof ResponseCanonicalListSupplierDto
     */
    response?: Array<SupplierDto>;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalListSupplierDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalMovementDetailDto
 */
export interface ResponseCanonicalMovementDetailDto {
    /**
     * 
     * @type {MovementDetailDto}
     * @memberof ResponseCanonicalMovementDetailDto
     */
    response?: MovementDetailDto;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalMovementDetailDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalMovementDto
 */
export interface ResponseCanonicalMovementDto {
    /**
     * 
     * @type {MovementDto}
     * @memberof ResponseCanonicalMovementDto
     */
    response?: MovementDto;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalMovementDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalMovementTypeDto
 */
export interface ResponseCanonicalMovementTypeDto {
    /**
     * 
     * @type {MovementTypeDto}
     * @memberof ResponseCanonicalMovementTypeDto
     */
    response?: MovementTypeDto;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalMovementTypeDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalProductDto
 */
export interface ResponseCanonicalProductDto {
    /**
     * 
     * @type {ProductDto}
     * @memberof ResponseCanonicalProductDto
     */
    response?: ProductDto;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalProductDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalProductRepositoryDto
 */
export interface ResponseCanonicalProductRepositoryDto {
    /**
     * 
     * @type {ProductRepositoryDto}
     * @memberof ResponseCanonicalProductRepositoryDto
     */
    response?: ProductRepositoryDto;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalProductRepositoryDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalRepositoryDto
 */
export interface ResponseCanonicalRepositoryDto {
    /**
     * 
     * @type {RepositoryDto}
     * @memberof ResponseCanonicalRepositoryDto
     */
    response?: RepositoryDto;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalRepositoryDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalSupplierDto
 */
export interface ResponseCanonicalSupplierDto {
    /**
     * 
     * @type {SupplierDto}
     * @memberof ResponseCanonicalSupplierDto
     */
    response?: SupplierDto;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalSupplierDto
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseCanonicalstring
 */
export interface ResponseCanonicalstring {
    /**
     * 
     * @type {string}
     * @memberof ResponseCanonicalstring
     */
    response?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseCanonicalstring
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface SupplierDto
 */
export interface SupplierDto {
    /**
     * 
     * @type {string}
     * @memberof SupplierDto
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierDto
     */
    code?: string;
    /**
     * 
     * @type {Date}
     * @memberof SupplierDto
     */
    createdAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof SupplierDto
     */
    email?: string;
    /**
     * 
     * @type {number}
     * @memberof SupplierDto
     */
    id?: number;
    /**
     * 
     * @type {Array<MovementDto>}
     * @memberof SupplierDto
     */
    movements?: Array<MovementDto>;
    /**
     * 
     * @type {string}
     * @memberof SupplierDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SupplierDto
     */
    phone?: string;
    /**
     * 
     * @type {Array<ProductDto>}
     * @memberof SupplierDto
     */
    products?: Array<ProductDto>;
    /**
     * 
     * @type {Date}
     * @memberof SupplierDto
     */
    updatedAt?: Date;
}


/**
 * CategoryControllerApi - fetch parameter creator
 * @export
 */
export const CategoryControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createCategory
         * @param {CategoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(entityParam: CategoryDto, options: any = {}): FetchArgs {
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling createCategory.');
            }
            const localVarPath = `/categories/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CategoryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findCategory
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCategory(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findCategory.');
            }
            const localVarPath = `/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listCategories
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {number} [parentCategoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories({ skip, limit, from, to, name, description, parentCategoryId, options = {} }: { skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, parentCategoryId?: number, options: any }): FetchArgs {
            const localVarPath = `/categories/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (parentCategoryId !== undefined) {
                localVarQueryParameter['parentCategoryId'] = parentCategoryId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateCategory
         * @param {number} id id
         * @param {CategoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: number, entityParam: CategoryDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCategory.');
            }
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling updateCategory.');
            }
            const localVarPath = `/categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CategoryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryControllerApi - functional programming interface
 * @export
 */
export const CategoryControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createCategory
         * @param {CategoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(entityParam: CategoryDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalCategoryDto> {
            const localVarFetchArgs = CategoryControllerApiFetchParamCreator(configuration).createCategory(entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findCategory
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCategory(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalCategoryDto> {
            const localVarFetchArgs = CategoryControllerApiFetchParamCreator(configuration).findCategory(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listCategories
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {number} [parentCategoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories({ skip, limit, from, to, name, description, parentCategoryId, options = {} }: { skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, parentCategoryId?: number, options?: any }): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalListCategoryDto> {
            const localVarFetchArgs = CategoryControllerApiFetchParamCreator(configuration).listCategories({ skip, limit, from, to, name, description, parentCategoryId, options });
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateCategory
         * @param {number} id id
         * @param {CategoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: number, entityParam: CategoryDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalCategoryDto> {
            const localVarFetchArgs = CategoryControllerApiFetchParamCreator(configuration).updateCategory(id, entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CategoryControllerApi - factory interface
 * @export
 */
export const CategoryControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createCategory
         * @param {CategoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(entityParam: CategoryDto, options?: any) {
            return CategoryControllerApiFp(configuration).createCategory(entityParam, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findCategory
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCategory(id: number, options?: any) {
            return CategoryControllerApiFp(configuration).findCategory(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary listCategories
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {number} [parentCategoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories({ skip, limit, from, to, name, description, parentCategoryId, options = {} }: { skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, parentCategoryId?: number, options?: any }) {
            return CategoryControllerApiFp(configuration).listCategories({ skip, limit, from, to, name, description, parentCategoryId, options })(fetch, basePath);
        },
        /**
         * 
         * @summary updateCategory
         * @param {number} id id
         * @param {CategoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: number, entityParam: CategoryDto, options?: any) {
            return CategoryControllerApiFp(configuration).updateCategory(id, entityParam, options)(fetch, basePath);
        },
    };
};

/**
 * CategoryControllerApi - object-oriented interface
 * @export
 * @class CategoryControllerApi
 * @extends {BaseAPI}
 */
export class CategoryControllerApi extends BaseAPI {
    /**
     * 
     * @summary createCategory
     * @param {CategoryDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public createCategory(entityParam: CategoryDto, options?: any) {
        return CategoryControllerApiFp(this.configuration).createCategory(entityParam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findCategory
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public findCategory(id: number, options?: any) {
        return CategoryControllerApiFp(this.configuration).findCategory(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listCategories
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {number} [parentCategoryId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public listCategories({ skip, limit, from, to, name, description, parentCategoryId, options = {} }: { skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, parentCategoryId?: number, options?: any }) {
        return CategoryControllerApiFp(this.configuration).listCategories({ skip, limit, from, to, name, description, parentCategoryId, options })(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateCategory
     * @param {number} id id
     * @param {CategoryDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public updateCategory(id: number, entityParam: CategoryDto, options?: any) {
        return CategoryControllerApiFp(this.configuration).updateCategory(id, entityParam, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerControllerApi - fetch parameter creator
 * @export
 */
export const CustomerControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createCustomer
         * @param {CustomerDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(entityParam: CustomerDto, options: any = {}): FetchArgs {
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling createCustomer.');
            }
            const localVarPath = `/customers/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findCustomer
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCustomer(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findCustomer.');
            }
            const localVarPath = `/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listCustomers
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {number} [movementId] 
         * @param {number} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomers({ skip, limit, from, to, name, movementId, productId, options = {} }: { skip?: number, limit?: number, from?: Date, to?: Date, name?: string, movementId?: number, productId?: number, options: any }): FetchArgs {
            const localVarPath = `/customers/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (movementId !== undefined) {
                localVarQueryParameter['movementId'] = movementId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateCustomer
         * @param {number} id id
         * @param {CustomerDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(id: number, entityParam: CustomerDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCustomer.');
            }
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling updateCustomer.');
            }
            const localVarPath = `/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerControllerApi - functional programming interface
 * @export
 */
export const CustomerControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createCustomer
         * @param {CustomerDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(entityParam: CustomerDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalCustomerDto> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).createCustomer(entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findCustomer
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCustomer(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalCustomerDto> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).findCustomer(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listCustomers
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {number} [movementId] 
         * @param {number} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomers({ skip, limit, from, to, name, movementId, productId, options = {} }: { skip?: number, limit?: number, from?: Date, to?: Date, name?: string, movementId?: number, productId?: number, options: any }): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalListCustomerDto> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).listCustomers({ skip, limit, from, to, name, movementId, productId, options });
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateCustomer
         * @param {number} id id
         * @param {CustomerDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(id: number, entityParam: CustomerDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalCustomerDto> {
            const localVarFetchArgs = CustomerControllerApiFetchParamCreator(configuration).updateCustomer(id, entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerControllerApi - factory interface
 * @export
 */
export const CustomerControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createCustomer
         * @param {CustomerDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(entityParam: CustomerDto, options?: any) {
            return CustomerControllerApiFp(configuration).createCustomer(entityParam, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findCustomer
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCustomer(id: number, options?: any) {
            return CustomerControllerApiFp(configuration).findCustomer(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary listCustomers
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {number} [movementId] 
         * @param {number} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomers({ skip, limit, from, to, name, movementId, productId, options = {} }: { skip?: number, limit?: number, from?: Date, to?: Date, name?: string, movementId?: number, productId?: number, options: any }) {
            return CustomerControllerApiFp(configuration).listCustomers({ skip, limit, from, to, name, movementId, productId, options })(fetch, basePath);
        },
        /**
         * 
         * @summary updateCustomer
         * @param {number} id id
         * @param {CustomerDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(id: number, entityParam: CustomerDto, options?: any) {
            return CustomerControllerApiFp(configuration).updateCustomer(id, entityParam, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerControllerApi - object-oriented interface
 * @export
 * @class CustomerControllerApi
 * @extends {BaseAPI}
 */
export class CustomerControllerApi extends BaseAPI {
    /**
     * 
     * @summary createCustomer
     * @param {CustomerDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public createCustomer(entityParam: CustomerDto, options?: any) {
        return CustomerControllerApiFp(this.configuration).createCustomer(entityParam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findCustomer
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public findCustomer(id: number, options?: any) {
        return CustomerControllerApiFp(this.configuration).findCustomer(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listCustomers
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {string} [name] 
     * @param {number} [movementId] 
     * @param {number} [productId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public listCustomers({ skip, limit, from, to, name, movementId, productId, options = {} }: { skip?: number, limit?: number, from?: Date, to?: Date, name?: string, movementId?: number, productId?: number, options: any }) {
        return CustomerControllerApiFp(this.configuration).listCustomers({ skip, limit, from, to, name, movementId, productId, options })(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateCustomer
     * @param {number} id id
     * @param {CustomerDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerControllerApi
     */
    public updateCustomer(id: number, entityParam: CustomerDto, options?: any) {
        return CustomerControllerApiFp(this.configuration).updateCustomer(id, entityParam, options)(this.fetch, this.basePath);
    }

}

/**
 * MovementControllerApi - fetch parameter creator
 * @export
 */
export const MovementControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary findMovement
         * @param {number} movementId movementId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMovement(movementId: number, options: any = {}): FetchArgs {
            // verify required parameter 'movementId' is not null or undefined
            if (movementId === null || movementId === undefined) {
                throw new RequiredError('movementId','Required parameter movementId was null or undefined when calling findMovement.');
            }
            const localVarPath = `/movements/{movementId}`
                .replace(`{${"movementId"}}`, encodeURIComponent(String(movementId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary generateMovement
         * @param {MovementDto} movementInfo movementInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMovement(movementInfo: MovementDto, options: any = {}): FetchArgs {
            // verify required parameter 'movementInfo' is not null or undefined
            if (movementInfo === null || movementInfo === undefined) {
                throw new RequiredError('movementInfo','Required parameter movementInfo was null or undefined when calling generateMovement.');
            }
            const localVarPath = `/movements/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MovementDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(movementInfo || {}) : (movementInfo || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listMovements
         * @param {Array<number>} [movementDetailIds] 
         * @param {Array<number>} [productIds] 
         * @param {Array<number>} [movementTypeIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [sourceRepositoryId] 
         * @param {number} [targetRepositoryId] 
         * @param {number} [customerId] 
         * @param {number} [supplierId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMovements({ movementDetailIds, productIds, movementTypeIds, skip, limit, from, to, sourceRepositoryId, targetRepositoryId, customerId, supplierId, options = {} }: { movementDetailIds?: Array<number>, productIds?: Array<number>, movementTypeIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, sourceRepositoryId?: number, targetRepositoryId?: number, customerId?: number, supplierId?: number, options: any }): FetchArgs {
            const localVarPath = `/movements/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (movementDetailIds) {
                localVarQueryParameter['movementDetailIds'] = movementDetailIds;
            }

            if (productIds) {
                localVarQueryParameter['productIds'] = productIds;
            }

            if (movementTypeIds) {
                localVarQueryParameter['movementTypeIds'] = movementTypeIds;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            if (sourceRepositoryId !== undefined) {
                localVarQueryParameter['sourceRepositoryId'] = sourceRepositoryId;
            }

            if (targetRepositoryId !== undefined) {
                localVarQueryParameter['targetRepositoryId'] = targetRepositoryId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (supplierId !== undefined) {
                localVarQueryParameter['supplierId'] = supplierId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary rollbackMovement
         * @param {number} parentMovementId parentMovementId
         * @param {MovementDto} headerInfo headerInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackMovement(parentMovementId: number, headerInfo: MovementDto, options: any = {}): FetchArgs {
            // verify required parameter 'parentMovementId' is not null or undefined
            if (parentMovementId === null || parentMovementId === undefined) {
                throw new RequiredError('parentMovementId','Required parameter parentMovementId was null or undefined when calling rollbackMovement.');
            }
            // verify required parameter 'headerInfo' is not null or undefined
            if (headerInfo === null || headerInfo === undefined) {
                throw new RequiredError('headerInfo','Required parameter headerInfo was null or undefined when calling rollbackMovement.');
            }
            const localVarPath = `/movements/{parentMovementId}`
                .replace(`{${"parentMovementId"}}`, encodeURIComponent(String(parentMovementId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MovementDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(headerInfo || {}) : (headerInfo || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MovementControllerApi - functional programming interface
 * @export
 */
export const MovementControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary findMovement
         * @param {number} movementId movementId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMovement(movementId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalMovementDto> {
            const localVarFetchArgs = MovementControllerApiFetchParamCreator(configuration).findMovement(movementId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary generateMovement
         * @param {MovementDto} movementInfo movementInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMovement(movementInfo: MovementDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalMovementDto> {
            const localVarFetchArgs = MovementControllerApiFetchParamCreator(configuration).generateMovement(movementInfo, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listMovements
         * @param {Array<number>} [movementDetailIds] 
         * @param {Array<number>} [productIds] 
         * @param {Array<number>} [movementTypeIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [sourceRepositoryId] 
         * @param {number} [targetRepositoryId] 
         * @param {number} [customerId] 
         * @param {number} [supplierId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMovements({ movementDetailIds, productIds, movementTypeIds, skip, limit, from, to, sourceRepositoryId, targetRepositoryId, customerId, supplierId, options = {} }: { movementDetailIds?: Array<number>, productIds?: Array<number>, movementTypeIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, sourceRepositoryId?: number, targetRepositoryId?: number, customerId?: number, supplierId?: number, options: any }): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalListMovementDto> {
            const localVarFetchArgs = MovementControllerApiFetchParamCreator(configuration).listMovements({ movementDetailIds, productIds, movementTypeIds, skip, limit, from, to, sourceRepositoryId, targetRepositoryId, customerId, supplierId, options });
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary rollbackMovement
         * @param {number} parentMovementId parentMovementId
         * @param {MovementDto} headerInfo headerInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackMovement(parentMovementId: number, headerInfo: MovementDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalMovementDto> {
            const localVarFetchArgs = MovementControllerApiFetchParamCreator(configuration).rollbackMovement(parentMovementId, headerInfo, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MovementControllerApi - factory interface
 * @export
 */
export const MovementControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary findMovement
         * @param {number} movementId movementId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMovement(movementId: number, options?: any) {
            return MovementControllerApiFp(configuration).findMovement(movementId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary generateMovement
         * @param {MovementDto} movementInfo movementInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateMovement(movementInfo: MovementDto, options?: any) {
            return MovementControllerApiFp(configuration).generateMovement(movementInfo, options)(fetch, basePath);
        },
        /**
         * 
         * @summary listMovements
         * @param {Array<number>} [movementDetailIds] 
         * @param {Array<number>} [productIds] 
         * @param {Array<number>} [movementTypeIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [sourceRepositoryId] 
         * @param {number} [targetRepositoryId] 
         * @param {number} [customerId] 
         * @param {number} [supplierId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMovements({ movementDetailIds, productIds, movementTypeIds, skip, limit, from, to, sourceRepositoryId, targetRepositoryId, customerId, supplierId, options = {} }: { movementDetailIds?: Array<number>, productIds?: Array<number>, movementTypeIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, sourceRepositoryId?: number, targetRepositoryId?: number, customerId?: number, supplierId?: number, options: any }) {
            return MovementControllerApiFp(configuration).listMovements({ movementDetailIds, productIds, movementTypeIds, skip, limit, from, to, sourceRepositoryId, targetRepositoryId, customerId, supplierId, options })(fetch, basePath);
        },
        /**
         * 
         * @summary rollbackMovement
         * @param {number} parentMovementId parentMovementId
         * @param {MovementDto} headerInfo headerInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackMovement(parentMovementId: number, headerInfo: MovementDto, options?: any) {
            return MovementControllerApiFp(configuration).rollbackMovement(parentMovementId, headerInfo, options)(fetch, basePath);
        },
    };
};

/**
 * MovementControllerApi - object-oriented interface
 * @export
 * @class MovementControllerApi
 * @extends {BaseAPI}
 */
export class MovementControllerApi extends BaseAPI {
    /**
     * 
     * @summary findMovement
     * @param {number} movementId movementId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovementControllerApi
     */
    public findMovement(movementId: number, options?: any) {
        return MovementControllerApiFp(this.configuration).findMovement(movementId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary generateMovement
     * @param {MovementDto} movementInfo movementInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovementControllerApi
     */
    public generateMovement(movementInfo: MovementDto, options?: any) {
        return MovementControllerApiFp(this.configuration).generateMovement(movementInfo, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listMovements
     * @param {Array<number>} [movementDetailIds] 
     * @param {Array<number>} [productIds] 
     * @param {Array<number>} [movementTypeIds] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {number} [sourceRepositoryId] 
     * @param {number} [targetRepositoryId] 
     * @param {number} [customerId] 
     * @param {number} [supplierId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovementControllerApi
     */
    public listMovements({ movementDetailIds, productIds, movementTypeIds, skip, limit, from, to, sourceRepositoryId, targetRepositoryId, customerId, supplierId, options = {} }: { movementDetailIds?: Array<number>, productIds?: Array<number>, movementTypeIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, sourceRepositoryId?: number, targetRepositoryId?: number, customerId?: number, supplierId?: number, options: any }) {
        return MovementControllerApiFp(this.configuration).listMovements({ movementDetailIds, productIds, movementTypeIds, skip, limit, from, to, sourceRepositoryId, targetRepositoryId, customerId, supplierId, options })(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary rollbackMovement
     * @param {number} parentMovementId parentMovementId
     * @param {MovementDto} headerInfo headerInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovementControllerApi
     */
    public rollbackMovement(parentMovementId: number, headerInfo: MovementDto, options?: any) {
        return MovementControllerApiFp(this.configuration).rollbackMovement(parentMovementId, headerInfo, options)(this.fetch, this.basePath);
    }

}

/**
 * MovementDetailControllerApi - fetch parameter creator
 * @export
 */
export const MovementDetailControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createMovementDetail
         * @param {MovementDetailDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMovementDetail(entityParam: MovementDetailDto, options: any = {}): FetchArgs {
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling createMovementDetail.');
            }
            const localVarPath = `/movement-details/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MovementDetailDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findMovementDetail
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMovementDetail(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findMovementDetail.');
            }
            const localVarPath = `/movement-details/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listMovementDetails
         * @param {Array<number>} [productIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [movementId] 
         * @param {boolean} [omitPositive] 
         * @param {boolean} [omitNegative] 
         * @param {number} [sourceRepositoryId] 
         * @param {number} [targetRepositoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMovementDetails({ productIds, skip, limit, from, to, movementId, omitPositive, omitNegative, sourceRepositoryId, targetRepositoryId, options = {} }: { productIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, movementId?: number, omitPositive?: boolean, omitNegative?: boolean, sourceRepositoryId?: number, targetRepositoryId?: number, options: any }): FetchArgs {
            const localVarPath = `/movement-details/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (productIds) {
                localVarQueryParameter['productIds'] = productIds;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            if (movementId !== undefined) {
                localVarQueryParameter['movementId'] = movementId;
            }

            if (omitPositive !== undefined) {
                localVarQueryParameter['omitPositive'] = omitPositive;
            }

            if (omitNegative !== undefined) {
                localVarQueryParameter['omitNegative'] = omitNegative;
            }

            if (sourceRepositoryId !== undefined) {
                localVarQueryParameter['sourceRepositoryId'] = sourceRepositoryId;
            }

            if (targetRepositoryId !== undefined) {
                localVarQueryParameter['targetRepositoryId'] = targetRepositoryId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateMovementDetail
         * @param {number} id id
         * @param {MovementDetailDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMovementDetail(id: number, entityParam: MovementDetailDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateMovementDetail.');
            }
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling updateMovementDetail.');
            }
            const localVarPath = `/movement-details/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MovementDetailDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MovementDetailControllerApi - functional programming interface
 * @export
 */
export const MovementDetailControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createMovementDetail
         * @param {MovementDetailDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMovementDetail(entityParam: MovementDetailDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalMovementDetailDto> {
            const localVarFetchArgs = MovementDetailControllerApiFetchParamCreator(configuration).createMovementDetail(entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findMovementDetail
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMovementDetail(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalMovementDetailDto> {
            const localVarFetchArgs = MovementDetailControllerApiFetchParamCreator(configuration).findMovementDetail(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listMovementDetails
         * @param {Array<number>} [productIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [movementId] 
         * @param {boolean} [omitPositive] 
         * @param {boolean} [omitNegative] 
         * @param {number} [sourceRepositoryId] 
         * @param {number} [targetRepositoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMovementDetails({ productIds, skip, limit, from, to, movementId, omitPositive, omitNegative, sourceRepositoryId, targetRepositoryId, options = {} }: { productIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, movementId?: number, omitPositive?: boolean, omitNegative?: boolean, sourceRepositoryId?: number, targetRepositoryId?: number, options: any }): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalListMovementDetailDto> {
            const localVarFetchArgs = MovementDetailControllerApiFetchParamCreator(configuration).listMovementDetails({ productIds, skip, limit, from, to, movementId, omitPositive, omitNegative, sourceRepositoryId, targetRepositoryId, options });
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateMovementDetail
         * @param {number} id id
         * @param {MovementDetailDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMovementDetail(id: number, entityParam: MovementDetailDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalMovementDetailDto> {
            const localVarFetchArgs = MovementDetailControllerApiFetchParamCreator(configuration).updateMovementDetail(id, entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MovementDetailControllerApi - factory interface
 * @export
 */
export const MovementDetailControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createMovementDetail
         * @param {MovementDetailDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMovementDetail(entityParam: MovementDetailDto, options?: any) {
            return MovementDetailControllerApiFp(configuration).createMovementDetail(entityParam, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findMovementDetail
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMovementDetail(id: number, options?: any) {
            return MovementDetailControllerApiFp(configuration).findMovementDetail(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary listMovementDetails
         * @param {Array<number>} [productIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {number} [movementId] 
         * @param {boolean} [omitPositive] 
         * @param {boolean} [omitNegative] 
         * @param {number} [sourceRepositoryId] 
         * @param {number} [targetRepositoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMovementDetails({ productIds, skip, limit, from, to, movementId, omitPositive, omitNegative, sourceRepositoryId, targetRepositoryId, options = {} }: { productIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, movementId?: number, omitPositive?: boolean, omitNegative?: boolean, sourceRepositoryId?: number, targetRepositoryId?: number, options: any }) {
            return MovementDetailControllerApiFp(configuration).listMovementDetails({ productIds, skip, limit, from, to, movementId, omitPositive, omitNegative, sourceRepositoryId, targetRepositoryId, options })(fetch, basePath);
        },
        /**
         * 
         * @summary updateMovementDetail
         * @param {number} id id
         * @param {MovementDetailDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMovementDetail(id: number, entityParam: MovementDetailDto, options?: any) {
            return MovementDetailControllerApiFp(configuration).updateMovementDetail(id, entityParam, options)(fetch, basePath);
        },
    };
};

/**
 * MovementDetailControllerApi - object-oriented interface
 * @export
 * @class MovementDetailControllerApi
 * @extends {BaseAPI}
 */
export class MovementDetailControllerApi extends BaseAPI {
    /**
     * 
     * @summary createMovementDetail
     * @param {MovementDetailDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovementDetailControllerApi
     */
    public createMovementDetail(entityParam: MovementDetailDto, options?: any) {
        return MovementDetailControllerApiFp(this.configuration).createMovementDetail(entityParam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findMovementDetail
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovementDetailControllerApi
     */
    public findMovementDetail(id: number, options?: any) {
        return MovementDetailControllerApiFp(this.configuration).findMovementDetail(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listMovementDetails
     * @param {Array<number>} [productIds] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {number} [movementId] 
     * @param {boolean} [omitPositive] 
     * @param {boolean} [omitNegative] 
     * @param {number} [sourceRepositoryId] 
     * @param {number} [targetRepositoryId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovementDetailControllerApi
     */
    public listMovementDetails({ productIds, skip, limit, from, to, movementId, omitPositive, omitNegative, sourceRepositoryId, targetRepositoryId, options = {} }: { productIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, movementId?: number, omitPositive?: boolean, omitNegative?: boolean, sourceRepositoryId?: number, targetRepositoryId?: number, options: any }) {
        return MovementDetailControllerApiFp(this.configuration).listMovementDetails({ productIds, skip, limit, from, to, movementId, omitPositive, omitNegative, sourceRepositoryId, targetRepositoryId, options })(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateMovementDetail
     * @param {number} id id
     * @param {MovementDetailDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovementDetailControllerApi
     */
    public updateMovementDetail(id: number, entityParam: MovementDetailDto, options?: any) {
        return MovementDetailControllerApiFp(this.configuration).updateMovementDetail(id, entityParam, options)(this.fetch, this.basePath);
    }

}

/**
 * MovementTypeControllerApi - fetch parameter creator
 * @export
 */
export const MovementTypeControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createMovementType
         * @param {MovementTypeDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMovementType(entityParam: MovementTypeDto, options: any = {}): FetchArgs {
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling createMovementType.');
            }
            const localVarPath = `/movement-types/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MovementTypeDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findMovementType
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMovementType(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findMovementType.');
            }
            const localVarPath = `/movement-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listMovementTypes
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {number} [sourceRepositoryId] 
         * @param {number} [targetRepositoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMovementTypes({ skip, limit, from, to, name, description, sourceRepositoryId, targetRepositoryId, options = {} }: { skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, sourceRepositoryId?: number, targetRepositoryId?: number, options: any }): FetchArgs {
            const localVarPath = `/movement-types/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sourceRepositoryId !== undefined) {
                localVarQueryParameter['sourceRepositoryId'] = sourceRepositoryId;
            }

            if (targetRepositoryId !== undefined) {
                localVarQueryParameter['targetRepositoryId'] = targetRepositoryId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateMovementType
         * @param {number} id id
         * @param {MovementTypeDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMovementType(id: number, entityParam: MovementTypeDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateMovementType.');
            }
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling updateMovementType.');
            }
            const localVarPath = `/movement-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MovementTypeDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MovementTypeControllerApi - functional programming interface
 * @export
 */
export const MovementTypeControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createMovementType
         * @param {MovementTypeDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMovementType(entityParam: MovementTypeDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalMovementTypeDto> {
            const localVarFetchArgs = MovementTypeControllerApiFetchParamCreator(configuration).createMovementType(entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findMovementType
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMovementType(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalMovementTypeDto> {
            const localVarFetchArgs = MovementTypeControllerApiFetchParamCreator(configuration).findMovementType(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listMovementTypes
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {number} [sourceRepositoryId] 
         * @param {number} [targetRepositoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMovementTypes({ skip, limit, from, to, name, description, sourceRepositoryId, targetRepositoryId, options = {} }: { skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, sourceRepositoryId?: number, targetRepositoryId?: number, options: any }): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalListMovementTypeDto> {
            const localVarFetchArgs = MovementTypeControllerApiFetchParamCreator(configuration).listMovementTypes({ skip, limit, from, to, name, description, sourceRepositoryId, targetRepositoryId, options });
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateMovementType
         * @param {number} id id
         * @param {MovementTypeDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMovementType(id: number, entityParam: MovementTypeDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalMovementTypeDto> {
            const localVarFetchArgs = MovementTypeControllerApiFetchParamCreator(configuration).updateMovementType(id, entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MovementTypeControllerApi - factory interface
 * @export
 */
export const MovementTypeControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createMovementType
         * @param {MovementTypeDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMovementType(entityParam: MovementTypeDto, options?: any) {
            return MovementTypeControllerApiFp(configuration).createMovementType(entityParam, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findMovementType
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMovementType(id: number, options?: any) {
            return MovementTypeControllerApiFp(configuration).findMovementType(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary listMovementTypes
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {number} [sourceRepositoryId] 
         * @param {number} [targetRepositoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMovementTypes({ skip, limit, from, to, name, description, sourceRepositoryId, targetRepositoryId, options = {} }: { skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, sourceRepositoryId?: number, targetRepositoryId?: number, options: any }) {
            return MovementTypeControllerApiFp(configuration).listMovementTypes({ skip, limit, from, to, name, description, sourceRepositoryId, targetRepositoryId, options })(fetch, basePath);
        },
        /**
         * 
         * @summary updateMovementType
         * @param {number} id id
         * @param {MovementTypeDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMovementType(id: number, entityParam: MovementTypeDto, options?: any) {
            return MovementTypeControllerApiFp(configuration).updateMovementType(id, entityParam, options)(fetch, basePath);
        },
    };
};

/**
 * MovementTypeControllerApi - object-oriented interface
 * @export
 * @class MovementTypeControllerApi
 * @extends {BaseAPI}
 */
export class MovementTypeControllerApi extends BaseAPI {
    /**
     * 
     * @summary createMovementType
     * @param {MovementTypeDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovementTypeControllerApi
     */
    public createMovementType(entityParam: MovementTypeDto, options?: any) {
        return MovementTypeControllerApiFp(this.configuration).createMovementType(entityParam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findMovementType
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovementTypeControllerApi
     */
    public findMovementType(id: number, options?: any) {
        return MovementTypeControllerApiFp(this.configuration).findMovementType(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listMovementTypes
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {number} [sourceRepositoryId] 
     * @param {number} [targetRepositoryId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovementTypeControllerApi
     */
    public listMovementTypes({ skip, limit, from, to, name, description, sourceRepositoryId, targetRepositoryId, options = {} }: { skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, sourceRepositoryId?: number, targetRepositoryId?: number, options: any }) {
        return MovementTypeControllerApiFp(this.configuration).listMovementTypes({ skip, limit, from, to, name, description, sourceRepositoryId, targetRepositoryId, options })(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateMovementType
     * @param {number} id id
     * @param {MovementTypeDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MovementTypeControllerApi
     */
    public updateMovementType(id: number, entityParam: MovementTypeDto, options?: any) {
        return MovementTypeControllerApiFp(this.configuration).updateMovementType(id, entityParam, options)(this.fetch, this.basePath);
    }

}

/**
 * ProductControllerApi - fetch parameter creator
 * @export
 */
export const ProductControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createProduct
         * @param {ProductDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(entityParam: ProductDto, options: any = {}): FetchArgs {
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling createProduct.');
            }
            const localVarPath = `/products/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProductDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findProduct
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProduct(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findProduct.');
            }
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listProducts
         * @param {Array<number>} [sourceSupplierIds] 
         * @param {Array<number>} [customerIds] 
         * @param {Array<number>} [supplierIds] 
         * @param {Array<number>} [categoryIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts({ sourceSupplierIds, customerIds, supplierIds, categoryIds, skip, limit, from, to, name, description, options = {} }: { sourceSupplierIds?: Array<number>, customerIds?: Array<number>, supplierIds?: Array<number>, categoryIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, options: any }): FetchArgs {
            const localVarPath = `/products/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceSupplierIds) {
                localVarQueryParameter['sourceSupplierIds'] = sourceSupplierIds;
            }

            if (customerIds) {
                localVarQueryParameter['customerIds'] = customerIds;
            }

            if (supplierIds) {
                localVarQueryParameter['supplierIds'] = supplierIds;
            }

            if (categoryIds) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateProduct
         * @param {number} id id
         * @param {ProductDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: number, entityParam: ProductDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateProduct.');
            }
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling updateProduct.');
            }
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProductDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductControllerApi - functional programming interface
 * @export
 */
export const ProductControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createProduct
         * @param {ProductDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(entityParam: ProductDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalProductDto> {
            const localVarFetchArgs = ProductControllerApiFetchParamCreator(configuration).createProduct(entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findProduct
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProduct(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalProductDto> {
            const localVarFetchArgs = ProductControllerApiFetchParamCreator(configuration).findProduct(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listProducts
         * @param {Array<number>} [sourceSupplierIds] 
         * @param {Array<number>} [customerIds] 
         * @param {Array<number>} [supplierIds] 
         * @param {Array<number>} [categoryIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts({ sourceSupplierIds, customerIds, supplierIds, categoryIds, skip, limit, from, to, name, description, options = {} }: { sourceSupplierIds?: Array<number>, customerIds?: Array<number>, supplierIds?: Array<number>, categoryIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, options: any }): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalListProductDto> {
            const localVarFetchArgs = ProductControllerApiFetchParamCreator(configuration).listProducts({ sourceSupplierIds, customerIds, supplierIds, categoryIds, skip, limit, from, to, name, description, options });
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateProduct
         * @param {number} id id
         * @param {ProductDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: number, entityParam: ProductDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalProductDto> {
            const localVarFetchArgs = ProductControllerApiFetchParamCreator(configuration).updateProduct(id, entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductControllerApi - factory interface
 * @export
 */
export const ProductControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createProduct
         * @param {ProductDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(entityParam: ProductDto, options?: any) {
            return ProductControllerApiFp(configuration).createProduct(entityParam, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findProduct
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProduct(id: number, options?: any) {
            return ProductControllerApiFp(configuration).findProduct(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary listProducts
         * @param {Array<number>} [sourceSupplierIds] 
         * @param {Array<number>} [customerIds] 
         * @param {Array<number>} [supplierIds] 
         * @param {Array<number>} [categoryIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts({ sourceSupplierIds, customerIds, supplierIds, categoryIds, skip, limit, from, to, name, description, options = {} }: { sourceSupplierIds?: Array<number>, customerIds?: Array<number>, supplierIds?: Array<number>, categoryIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, options: any }) {
            return ProductControllerApiFp(configuration).listProducts({ sourceSupplierIds, customerIds, supplierIds, categoryIds, skip, limit, from, to, name, description, options })(fetch, basePath);
        },
        /**
         * 
         * @summary updateProduct
         * @param {number} id id
         * @param {ProductDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: number, entityParam: ProductDto, options?: any) {
            return ProductControllerApiFp(configuration).updateProduct(id, entityParam, options)(fetch, basePath);
        },
    };
};

/**
 * ProductControllerApi - object-oriented interface
 * @export
 * @class ProductControllerApi
 * @extends {BaseAPI}
 */
export class ProductControllerApi extends BaseAPI {
    /**
     * 
     * @summary createProduct
     * @param {ProductDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public createProduct(entityParam: ProductDto, options?: any) {
        return ProductControllerApiFp(this.configuration).createProduct(entityParam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findProduct
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public findProduct(id: number, options?: any) {
        return ProductControllerApiFp(this.configuration).findProduct(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listProducts
     * @param {Array<number>} [sourceSupplierIds] 
     * @param {Array<number>} [customerIds] 
     * @param {Array<number>} [supplierIds] 
     * @param {Array<number>} [categoryIds] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public listProducts({ sourceSupplierIds, customerIds, supplierIds, categoryIds, skip, limit, from, to, name, description, options = {} }: { sourceSupplierIds?: Array<number>, customerIds?: Array<number>, supplierIds?: Array<number>, categoryIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, options: any }) {
        return ProductControllerApiFp(this.configuration).listProducts({ sourceSupplierIds, customerIds, supplierIds, categoryIds, skip, limit, from, to, name, description, options })(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateProduct
     * @param {number} id id
     * @param {ProductDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public updateProduct(id: number, entityParam: ProductDto, options?: any) {
        return ProductControllerApiFp(this.configuration).updateProduct(id, entityParam, options)(this.fetch, this.basePath);
    }

}

/**
 * ProductRepositoryControllerApi - fetch parameter creator
 * @export
 */
export const ProductRepositoryControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createProductRepository
         * @param {ProductRepositoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductRepository(entityParam: ProductRepositoryDto, options: any = {}): FetchArgs {
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling createProductRepository.');
            }
            const localVarPath = `/product-repositories/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProductRepositoryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findProductRepository
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProductRepository(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findProductRepository.');
            }
            const localVarPath = `/product-repositories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listProductRepositories
         * @param {Array<number>} [customerIds] 
         * @param {Array<number>} [supplierIds] 
         * @param {Array<number>} [sourceSupplierIds] 
         * @param {Array<number>} [categoryIds] 
         * @param {Array<number>} [repositoryIds] 
         * @param {Array<number>} [productIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductRepositories({ customerIds, supplierIds, sourceSupplierIds, categoryIds, repositoryIds, productIds, skip, limit, from, to, options = {} }: { customerIds?: Array<number>, supplierIds?: Array<number>, sourceSupplierIds?: Array<number>, categoryIds?: Array<number>, repositoryIds?: Array<number>, productIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, options: any }): FetchArgs {
            const localVarPath = `/product-repositories/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (customerIds) {
                localVarQueryParameter['customerIds'] = customerIds;
            }

            if (supplierIds) {
                localVarQueryParameter['supplierIds'] = supplierIds;
            }

            if (sourceSupplierIds) {
                localVarQueryParameter['sourceSupplierIds'] = sourceSupplierIds;
            }

            if (categoryIds) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (repositoryIds) {
                localVarQueryParameter['repositoryIds'] = repositoryIds;
            }

            if (productIds) {
                localVarQueryParameter['productIds'] = productIds;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateProductRepository
         * @param {number} id id
         * @param {ProductRepositoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductRepository(id: number, entityParam: ProductRepositoryDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateProductRepository.');
            }
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling updateProductRepository.');
            }
            const localVarPath = `/product-repositories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProductRepositoryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductRepositoryControllerApi - functional programming interface
 * @export
 */
export const ProductRepositoryControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createProductRepository
         * @param {ProductRepositoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductRepository(entityParam: ProductRepositoryDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalProductRepositoryDto> {
            const localVarFetchArgs = ProductRepositoryControllerApiFetchParamCreator(configuration).createProductRepository(entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findProductRepository
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProductRepository(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalProductRepositoryDto> {
            const localVarFetchArgs = ProductRepositoryControllerApiFetchParamCreator(configuration).findProductRepository(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listProductRepositories
         * @param {Array<number>} [customerIds] 
         * @param {Array<number>} [supplierIds] 
         * @param {Array<number>} [sourceSupplierIds] 
         * @param {Array<number>} [categoryIds] 
         * @param {Array<number>} [repositoryIds] 
         * @param {Array<number>} [productIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductRepositories({ customerIds, supplierIds, sourceSupplierIds, categoryIds, repositoryIds, productIds, skip, limit, from, to, options = {} }: { customerIds?: Array<number>, supplierIds?: Array<number>, sourceSupplierIds?: Array<number>, categoryIds?: Array<number>, repositoryIds?: Array<number>, productIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, options: any }): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalListProductRepositoryDto> {
            const localVarFetchArgs = ProductRepositoryControllerApiFetchParamCreator(configuration).listProductRepositories({ customerIds, supplierIds, sourceSupplierIds, categoryIds, repositoryIds, productIds, skip, limit, from, to, options });
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateProductRepository
         * @param {number} id id
         * @param {ProductRepositoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductRepository(id: number, entityParam: ProductRepositoryDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalProductRepositoryDto> {
            const localVarFetchArgs = ProductRepositoryControllerApiFetchParamCreator(configuration).updateProductRepository(id, entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductRepositoryControllerApi - factory interface
 * @export
 */
export const ProductRepositoryControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createProductRepository
         * @param {ProductRepositoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductRepository(entityParam: ProductRepositoryDto, options?: any) {
            return ProductRepositoryControllerApiFp(configuration).createProductRepository(entityParam, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findProductRepository
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProductRepository(id: number, options?: any) {
            return ProductRepositoryControllerApiFp(configuration).findProductRepository(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary listProductRepositories
         * @param {Array<number>} [customerIds] 
         * @param {Array<number>} [supplierIds] 
         * @param {Array<number>} [sourceSupplierIds] 
         * @param {Array<number>} [categoryIds] 
         * @param {Array<number>} [repositoryIds] 
         * @param {Array<number>} [productIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductRepositories({ customerIds, supplierIds, sourceSupplierIds, categoryIds, repositoryIds, productIds, skip, limit, from, to, options }: { customerIds?: Array<number>; supplierIds?: Array<number>; sourceSupplierIds?: Array<number>; categoryIds?: Array<number>; repositoryIds?: Array<number>; productIds?: Array<number>; skip?: number; limit?: number; from?: Date; to?: Date; options?: any; } = {}) {
            return ProductRepositoryControllerApiFp(configuration).listProductRepositories({ customerIds, supplierIds, sourceSupplierIds, categoryIds, repositoryIds, productIds, skip, limit, from, to, options })(fetch, basePath);
        },
        /**
         * 
         * @summary updateProductRepository
         * @param {number} id id
         * @param {ProductRepositoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductRepository(id: number, entityParam: ProductRepositoryDto, options?: any) {
            return ProductRepositoryControllerApiFp(configuration).updateProductRepository(id, entityParam, options)(fetch, basePath);
        },
    };
};

/**
 * ProductRepositoryControllerApi - object-oriented interface
 * @export
 * @class ProductRepositoryControllerApi
 * @extends {BaseAPI}
 */
export class ProductRepositoryControllerApi extends BaseAPI {
    /**
     * 
     * @summary createProductRepository
     * @param {ProductRepositoryDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductRepositoryControllerApi
     */
    public createProductRepository(entityParam: ProductRepositoryDto, options?: any) {
        return ProductRepositoryControllerApiFp(this.configuration).createProductRepository(entityParam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findProductRepository
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductRepositoryControllerApi
     */
    public findProductRepository(id: number, options?: any) {
        return ProductRepositoryControllerApiFp(this.configuration).findProductRepository(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listProductRepositories
     * @param {Array<number>} [customerIds] 
     * @param {Array<number>} [supplierIds] 
     * @param {Array<number>} [sourceSupplierIds] 
     * @param {Array<number>} [categoryIds] 
     * @param {Array<number>} [repositoryIds] 
     * @param {Array<number>} [productIds] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductRepositoryControllerApi
     */
    public listProductRepositories({ customerIds, supplierIds, sourceSupplierIds, categoryIds, repositoryIds, productIds, skip, limit, from, to, options }: { customerIds?: Array<number>; supplierIds?: Array<number>; sourceSupplierIds?: Array<number>; categoryIds?: Array<number>; repositoryIds?: Array<number>; productIds?: Array<number>; skip?: number; limit?: number; from?: Date; to?: Date; options?: any; } = {}) {
        return ProductRepositoryControllerApiFp(this.configuration).listProductRepositories({ customerIds, supplierIds, sourceSupplierIds, categoryIds, repositoryIds, productIds, skip, limit, from, to, options })(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateProductRepository
     * @param {number} id id
     * @param {ProductRepositoryDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductRepositoryControllerApi
     */
    public updateProductRepository(id: number, entityParam: ProductRepositoryDto, options?: any) {
        return ProductRepositoryControllerApiFp(this.configuration).updateProductRepository(id, entityParam, options)(this.fetch, this.basePath);
    }

}

/**
 * RepositoryControllerApi - fetch parameter creator
 * @export
 */
export const RepositoryControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createRepository
         * @param {RepositoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository(entityParam: RepositoryDto, options: any = {}): FetchArgs {
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling createRepository.');
            }
            const localVarPath = `/repositories/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RepositoryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findRepository
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRepository(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findRepository.');
            }
            const localVarPath = `/repositories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listRepositories
         * @param {Array<number>} [customerIds] 
         * @param {Array<number>} [supplierIds] 
         * @param {Array<number>} [categoryIds] 
         * @param {Array<number>} [productIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepositories({ customerIds, supplierIds, categoryIds, productIds, skip, limit, from, to, name, description, options = {} }: { customerIds?: Array<number>; supplierIds?: Array<number>; categoryIds?: Array<number>; productIds?: Array<number>; skip?: number; limit?: number; from?: Date; to?: Date; name?: string; description?: string; options?: any; }): FetchArgs {
            const localVarPath = `/repositories/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (customerIds) {
                localVarQueryParameter['customerIds'] = customerIds;
            }

            if (supplierIds) {
                localVarQueryParameter['supplierIds'] = supplierIds;
            }

            if (categoryIds) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (productIds) {
                localVarQueryParameter['productIds'] = productIds;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateRepository
         * @param {number} id id
         * @param {RepositoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository(id: number, entityParam: RepositoryDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateRepository.');
            }
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling updateRepository.');
            }
            const localVarPath = `/repositories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RepositoryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryControllerApi - functional programming interface
 * @export
 */
export const RepositoryControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createRepository
         * @param {RepositoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository(entityParam: RepositoryDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalRepositoryDto> {
            const localVarFetchArgs = RepositoryControllerApiFetchParamCreator(configuration).createRepository(entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findRepository
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRepository(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalRepositoryDto> {
            const localVarFetchArgs = RepositoryControllerApiFetchParamCreator(configuration).findRepository(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listRepositories
         * @param {Array<number>} [customerIds] 
         * @param {Array<number>} [supplierIds] 
         * @param {Array<number>} [categoryIds] 
         * @param {Array<number>} [productIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepositories({ customerIds, supplierIds, categoryIds, productIds, skip, limit, from, to, name, description, options }: { customerIds?: Array<number>; supplierIds?: Array<number>; categoryIds?: Array<number>; productIds?: Array<number>; skip?: number; limit?: number; from?: Date; to?: Date; name?: string; description?: string; options?: any; } = {}): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalListRepositoryDto> {
            const localVarFetchArgs = RepositoryControllerApiFetchParamCreator(configuration).listRepositories({ customerIds, supplierIds, categoryIds, productIds, skip, limit, from, to, name, description, options });
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateRepository
         * @param {number} id id
         * @param {RepositoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository(id: number, entityParam: RepositoryDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalRepositoryDto> {
            const localVarFetchArgs = RepositoryControllerApiFetchParamCreator(configuration).updateRepository(id, entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RepositoryControllerApi - factory interface
 * @export
 */
export const RepositoryControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createRepository
         * @param {RepositoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository(entityParam: RepositoryDto, options?: any) {
            return RepositoryControllerApiFp(configuration).createRepository(entityParam, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findRepository
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRepository(id: number, options?: any) {
            return RepositoryControllerApiFp(configuration).findRepository(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary listRepositories
         * @param {Array<number>} [customerIds] 
         * @param {Array<number>} [supplierIds] 
         * @param {Array<number>} [categoryIds] 
         * @param {Array<number>} [productIds] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepositories({ customerIds, supplierIds, categoryIds, productIds, skip, limit, from, to, name, description, options }: { customerIds?: Array<number>; supplierIds?: Array<number>; categoryIds?: Array<number>; productIds?: Array<number>; skip?: number; limit?: number; from?: Date; to?: Date; name?: string; description?: string; options?: any; } = {}) {
            return RepositoryControllerApiFp(configuration).listRepositories({ customerIds, supplierIds, categoryIds, productIds, skip, limit, from, to, name, description, options })(fetch, basePath);
        },
        /**
         * 
         * @summary updateRepository
         * @param {number} id id
         * @param {RepositoryDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository(id: number, entityParam: RepositoryDto, options?: any) {
            return RepositoryControllerApiFp(configuration).updateRepository(id, entityParam, options)(fetch, basePath);
        },
    };
};

/**
 * RepositoryControllerApi - object-oriented interface
 * @export
 * @class RepositoryControllerApi
 * @extends {BaseAPI}
 */
export class RepositoryControllerApi extends BaseAPI {
    /**
     * 
     * @summary createRepository
     * @param {RepositoryDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryControllerApi
     */
    public createRepository(entityParam: RepositoryDto, options?: any) {
        return RepositoryControllerApiFp(this.configuration).createRepository(entityParam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findRepository
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryControllerApi
     */
    public findRepository(id: number, options?: any) {
        return RepositoryControllerApiFp(this.configuration).findRepository(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listRepositories
     * @param {Array<number>} [customerIds] 
     * @param {Array<number>} [supplierIds] 
     * @param {Array<number>} [categoryIds] 
     * @param {Array<number>} [productIds] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryControllerApi
     */
    public listRepositories({ customerIds, supplierIds, categoryIds, productIds, skip, limit, from, to, name, description, options }: { customerIds?: Array<number>; supplierIds?: Array<number>; categoryIds?: Array<number>; productIds?: Array<number>; skip?: number; limit?: number; from?: Date; to?: Date; name?: string; description?: string; options?: any; } = {}) {
        return RepositoryControllerApiFp(this.configuration).listRepositories({ customerIds, supplierIds, categoryIds, productIds, skip, limit, from, to, name, description, options })(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateRepository
     * @param {number} id id
     * @param {RepositoryDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryControllerApi
     */
    public updateRepository(id: number, entityParam: RepositoryDto, options?: any) {
        return RepositoryControllerApiFp(this.configuration).updateRepository(id, entityParam, options)(this.fetch, this.basePath);
    }

}

/**
 * RootControllerApi - fetch parameter creator
 * @export
 */
export const RootControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary heartBeat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartBeat(options: any = {}): FetchArgs {
            const localVarPath = `/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootControllerApi - functional programming interface
 * @export
 */
export const RootControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary heartBeat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartBeat(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalstring> {
            const localVarFetchArgs = RootControllerApiFetchParamCreator(configuration).heartBeat(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RootControllerApi - factory interface
 * @export
 */
export const RootControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary heartBeat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartBeat(options?: any) {
            return RootControllerApiFp(configuration).heartBeat(options)(fetch, basePath);
        },
    };
};

/**
 * RootControllerApi - object-oriented interface
 * @export
 * @class RootControllerApi
 * @extends {BaseAPI}
 */
export class RootControllerApi extends BaseAPI {
    /**
     * 
     * @summary heartBeat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootControllerApi
     */
    public heartBeat(options?: any) {
        return RootControllerApiFp(this.configuration).heartBeat(options)(this.fetch, this.basePath);
    }

}

/**
 * SupplierControllerApi - fetch parameter creator
 * @export
 */
export const SupplierControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createSupplier
         * @param {SupplierDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupplier(entityParam: SupplierDto, options: any = {}): FetchArgs {
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling createSupplier.');
            }
            const localVarPath = `/suppliers/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SupplierDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findSupplier
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSupplier(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findSupplier.');
            }
            const localVarPath = `/suppliers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary listSuppliers
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {number} [movementId] 
         * @param {number} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuppliers({ skip, limit, from, to, name, movementId, productId, options = {} }: { skip?: number; limit?: number; from?: Date; to?: Date; name?: string; movementId?: number; productId?: number; options?: any; } = {}): FetchArgs {
            const localVarPath = `/suppliers/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any).toISOString();
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any).toISOString();
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (movementId !== undefined) {
                localVarQueryParameter['movementId'] = movementId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateSupplier
         * @param {number} id id
         * @param {SupplierDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplier(id: number, entityParam: SupplierDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSupplier.');
            }
            // verify required parameter 'entityParam' is not null or undefined
            if (entityParam === null || entityParam === undefined) {
                throw new RequiredError('entityParam','Required parameter entityParam was null or undefined when calling updateSupplier.');
            }
            const localVarPath = `/suppliers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SupplierDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(entityParam || {}) : (entityParam || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupplierControllerApi - functional programming interface
 * @export
 */
export const SupplierControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createSupplier
         * @param {SupplierDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupplier(entityParam: SupplierDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalSupplierDto> {
            const localVarFetchArgs = SupplierControllerApiFetchParamCreator(configuration).createSupplier(entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findSupplier
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSupplier(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalSupplierDto> {
            const localVarFetchArgs = SupplierControllerApiFetchParamCreator(configuration).findSupplier(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary listSuppliers
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {number} [movementId] 
         * @param {number} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuppliers({ skip, limit, from, to, name, movementId, productId, options }: { skip?: number; limit?: number; from?: Date; to?: Date; name?: string; movementId?: number; productId?: number; options?: any; } = {}): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalListSupplierDto> {
            const localVarFetchArgs = SupplierControllerApiFetchParamCreator(configuration).listSuppliers({ skip, limit, from, to, name, movementId, productId, options });
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateSupplier
         * @param {number} id id
         * @param {SupplierDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplier(id: number, entityParam: SupplierDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseCanonicalSupplierDto> {
            const localVarFetchArgs = SupplierControllerApiFetchParamCreator(configuration).updateSupplier(id, entityParam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SupplierControllerApi - factory interface
 * @export
 */
export const SupplierControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createSupplier
         * @param {SupplierDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupplier(entityParam: SupplierDto, options?: any) {
            return SupplierControllerApiFp(configuration).createSupplier(entityParam, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findSupplier
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSupplier(id: number, options?: any) {
            return SupplierControllerApiFp(configuration).findSupplier(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary listSuppliers
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {Date} [from] 
         * @param {Date} [to] 
         * @param {string} [name] 
         * @param {number} [movementId] 
         * @param {number} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuppliers({ skip, limit, from, to, name, movementId, productId, options }: { skip?: number; limit?: number; from?: Date; to?: Date; name?: string; movementId?: number; productId?: number; options?: any; } = {}) {
            return SupplierControllerApiFp(configuration).listSuppliers({ skip, limit, from, to, name, movementId, productId, options })(fetch, basePath);
        },
        /**
         * 
         * @summary updateSupplier
         * @param {number} id id
         * @param {SupplierDto} entityParam entityParam
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplier(id: number, entityParam: SupplierDto, options?: any) {
            return SupplierControllerApiFp(configuration).updateSupplier(id, entityParam, options)(fetch, basePath);
        },
    };
};

/**
 * SupplierControllerApi - object-oriented interface
 * @export
 * @class SupplierControllerApi
 * @extends {BaseAPI}
 */
export class SupplierControllerApi extends BaseAPI {
    /**
     * 
     * @summary createSupplier
     * @param {SupplierDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierControllerApi
     */
    public createSupplier(entityParam: SupplierDto, options?: any) {
        return SupplierControllerApiFp(this.configuration).createSupplier(entityParam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findSupplier
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierControllerApi
     */
    public findSupplier(id: number, options?: any) {
        return SupplierControllerApiFp(this.configuration).findSupplier(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary listSuppliers
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {Date} [from] 
     * @param {Date} [to] 
     * @param {string} [name] 
     * @param {number} [movementId] 
     * @param {number} [productId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierControllerApi
     */
    public listSuppliers({ skip, limit, from, to, name, movementId, productId, options }: { skip?: number; limit?: number; from?: Date; to?: Date; name?: string; movementId?: number; productId?: number; options?: any; } = {}) {
        return SupplierControllerApiFp(this.configuration).listSuppliers({ skip, limit, from, to, name, movementId, productId, options })(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateSupplier
     * @param {number} id id
     * @param {SupplierDto} entityParam entityParam
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupplierControllerApi
     */
    public updateSupplier(id: number, entityParam: SupplierDto, options?: any) {
        return SupplierControllerApiFp(this.configuration).updateSupplier(id, entityParam, options)(this.fetch, this.basePath);
    }

}

