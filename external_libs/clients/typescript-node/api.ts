/**
 * Inventory Management System
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://localhost:9091';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class CategoryDto {
    'createdAt'?: Date;
    'description'?: string;
    'id'?: number;
    'name'?: string;
    'parentCategory'?: CategoryDto;
    'products'?: Array<ProductDto>;
    'subCategories'?: Array<CategoryDto>;
    'supplier'?: SupplierDto;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "parentCategory",
            "baseName": "parentCategory",
            "type": "CategoryDto"
        },
        {
            "name": "products",
            "baseName": "products",
            "type": "Array<ProductDto>"
        },
        {
            "name": "subCategories",
            "baseName": "subCategories",
            "type": "Array<CategoryDto>"
        },
        {
            "name": "supplier",
            "baseName": "supplier",
            "type": "SupplierDto"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CategoryDto.attributeTypeMap;
    }
}

export class CustomerDto {
    'address'?: string;
    'code'?: string;
    'createdAt'?: Date;
    'email'?: string;
    'id'?: number;
    'movements'?: Array<MovementDto>;
    'name'?: string;
    'phone'?: string;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "movements",
            "baseName": "movements",
            "type": "Array<MovementDto>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CustomerDto.attributeTypeMap;
    }
}

export class MovementDetailDto {
    'createdAt'?: Date;
    'id'?: number;
    'movement'?: MovementDto;
    'product'?: ProductDto;
    'quantity'?: number;
    'sourceProductRepository'?: ProductRepositoryDto;
    'targetProductRepository'?: ProductRepositoryDto;
    'updatedAt'?: Date;
    'value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "movement",
            "baseName": "movement",
            "type": "MovementDto"
        },
        {
            "name": "product",
            "baseName": "product",
            "type": "ProductDto"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "sourceProductRepository",
            "baseName": "sourceProductRepository",
            "type": "ProductRepositoryDto"
        },
        {
            "name": "targetProductRepository",
            "baseName": "targetProductRepository",
            "type": "ProductRepositoryDto"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MovementDetailDto.attributeTypeMap;
    }
}

export class MovementDto {
    'childrenMovement'?: Array<MovementDto>;
    'code'?: string;
    'comments'?: string;
    'createdAt'?: Date;
    'customer'?: CustomerDto;
    'id'?: number;
    'movement'?: MovementDto;
    'movementDate'?: Date;
    'movementDetails'?: Array<MovementDetailDto>;
    'movementType'?: MovementTypeDto;
    'supplier'?: SupplierDto;
    'totalValue'?: number;
    'type'?: number;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "childrenMovement",
            "baseName": "childrenMovement",
            "type": "Array<MovementDto>"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "CustomerDto"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "movement",
            "baseName": "movement",
            "type": "MovementDto"
        },
        {
            "name": "movementDate",
            "baseName": "movementDate",
            "type": "Date"
        },
        {
            "name": "movementDetails",
            "baseName": "movementDetails",
            "type": "Array<MovementDetailDto>"
        },
        {
            "name": "movementType",
            "baseName": "movementType",
            "type": "MovementTypeDto"
        },
        {
            "name": "supplier",
            "baseName": "supplier",
            "type": "SupplierDto"
        },
        {
            "name": "totalValue",
            "baseName": "totalValue",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return MovementDto.attributeTypeMap;
    }
}

export class MovementTypeDto {
    'createdAt'?: Date;
    'description'?: string;
    'id'?: number;
    'movements'?: Array<MovementDto>;
    'name'?: string;
    'parentMovementRequired'?: boolean;
    'sourceRepository'?: RepositoryDto;
    'targetRepository'?: RepositoryDto;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "movements",
            "baseName": "movements",
            "type": "Array<MovementDto>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "parentMovementRequired",
            "baseName": "parentMovementRequired",
            "type": "boolean"
        },
        {
            "name": "sourceRepository",
            "baseName": "sourceRepository",
            "type": "RepositoryDto"
        },
        {
            "name": "targetRepository",
            "baseName": "targetRepository",
            "type": "RepositoryDto"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return MovementTypeDto.attributeTypeMap;
    }
}

export class ProductDto {
    'category'?: CategoryDto;
    'code'?: string;
    'createdAt'?: Date;
    'description'?: string;
    'id'?: number;
    'movementDetails'?: Array<MovementDetailDto>;
    'name'?: string;
    'photo'?: string;
    'productRepositories'?: Array<ProductRepositoryDto>;
    'supplier'?: SupplierDto;
    'unitType'?: number;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "CategoryDto"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "movementDetails",
            "baseName": "movementDetails",
            "type": "Array<MovementDetailDto>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "photo",
            "baseName": "photo",
            "type": "string"
        },
        {
            "name": "productRepositories",
            "baseName": "productRepositories",
            "type": "Array<ProductRepositoryDto>"
        },
        {
            "name": "supplier",
            "baseName": "supplier",
            "type": "SupplierDto"
        },
        {
            "name": "unitType",
            "baseName": "unitType",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ProductDto.attributeTypeMap;
    }
}

export class ProductRepositoryDto {
    'createdAt'?: Date;
    'currentQuantity'?: number;
    'id'?: number;
    'negativeMovements'?: Array<MovementDetailDto>;
    'positiveMovements'?: Array<MovementDetailDto>;
    'price'?: number;
    'product'?: ProductDto;
    'repository'?: RepositoryDto;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "currentQuantity",
            "baseName": "currentQuantity",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "negativeMovements",
            "baseName": "negativeMovements",
            "type": "Array<MovementDetailDto>"
        },
        {
            "name": "positiveMovements",
            "baseName": "positiveMovements",
            "type": "Array<MovementDetailDto>"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "product",
            "baseName": "product",
            "type": "ProductDto"
        },
        {
            "name": "repository",
            "baseName": "repository",
            "type": "RepositoryDto"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ProductRepositoryDto.attributeTypeMap;
    }
}

export class RepositoryDto {
    'createdAt'?: Date;
    'description'?: string;
    'external'?: boolean;
    'id'?: number;
    'name'?: string;
    'productRepositories'?: Array<ProductRepositoryDto>;
    'sourceMovementTypes'?: Array<MovementTypeDto>;
    'targetMovementTypes'?: Array<MovementTypeDto>;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "external",
            "baseName": "external",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "productRepositories",
            "baseName": "productRepositories",
            "type": "Array<ProductRepositoryDto>"
        },
        {
            "name": "sourceMovementTypes",
            "baseName": "sourceMovementTypes",
            "type": "Array<MovementTypeDto>"
        },
        {
            "name": "targetMovementTypes",
            "baseName": "targetMovementTypes",
            "type": "Array<MovementTypeDto>"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return RepositoryDto.attributeTypeMap;
    }
}

export class ResponseCanonicalCategoryDto {
    'response'?: CategoryDto;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "CategoryDto"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalCategoryDto.attributeTypeMap;
    }
}

export class ResponseCanonicalCustomerDto {
    'response'?: CustomerDto;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "CustomerDto"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalCustomerDto.attributeTypeMap;
    }
}

export class ResponseCanonicalListCategoryDto {
    'response'?: Array<CategoryDto>;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Array<CategoryDto>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalListCategoryDto.attributeTypeMap;
    }
}

export class ResponseCanonicalListCustomerDto {
    'response'?: Array<CustomerDto>;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Array<CustomerDto>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalListCustomerDto.attributeTypeMap;
    }
}

export class ResponseCanonicalListMovementDetailDto {
    'response'?: Array<MovementDetailDto>;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Array<MovementDetailDto>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalListMovementDetailDto.attributeTypeMap;
    }
}

export class ResponseCanonicalListMovementDto {
    'response'?: Array<MovementDto>;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Array<MovementDto>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalListMovementDto.attributeTypeMap;
    }
}

export class ResponseCanonicalListMovementTypeDto {
    'response'?: Array<MovementTypeDto>;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Array<MovementTypeDto>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalListMovementTypeDto.attributeTypeMap;
    }
}

export class ResponseCanonicalListProductDto {
    'response'?: Array<ProductDto>;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Array<ProductDto>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalListProductDto.attributeTypeMap;
    }
}

export class ResponseCanonicalListProductRepositoryDto {
    'response'?: Array<ProductRepositoryDto>;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Array<ProductRepositoryDto>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalListProductRepositoryDto.attributeTypeMap;
    }
}

export class ResponseCanonicalListRepositoryDto {
    'response'?: Array<RepositoryDto>;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Array<RepositoryDto>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalListRepositoryDto.attributeTypeMap;
    }
}

export class ResponseCanonicalListSupplierDto {
    'response'?: Array<SupplierDto>;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "Array<SupplierDto>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalListSupplierDto.attributeTypeMap;
    }
}

export class ResponseCanonicalMovementDetailDto {
    'response'?: MovementDetailDto;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "MovementDetailDto"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalMovementDetailDto.attributeTypeMap;
    }
}

export class ResponseCanonicalMovementDto {
    'response'?: MovementDto;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "MovementDto"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalMovementDto.attributeTypeMap;
    }
}

export class ResponseCanonicalMovementTypeDto {
    'response'?: MovementTypeDto;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "MovementTypeDto"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalMovementTypeDto.attributeTypeMap;
    }
}

export class ResponseCanonicalProductDto {
    'response'?: ProductDto;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "ProductDto"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalProductDto.attributeTypeMap;
    }
}

export class ResponseCanonicalProductRepositoryDto {
    'response'?: ProductRepositoryDto;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "ProductRepositoryDto"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalProductRepositoryDto.attributeTypeMap;
    }
}

export class ResponseCanonicalRepositoryDto {
    'response'?: RepositoryDto;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "RepositoryDto"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalRepositoryDto.attributeTypeMap;
    }
}

export class ResponseCanonicalSupplierDto {
    'response'?: SupplierDto;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "SupplierDto"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalSupplierDto.attributeTypeMap;
    }
}

export class ResponseCanonicalstring {
    'response'?: string;
    'status'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseCanonicalstring.attributeTypeMap;
    }
}

export class SupplierDto {
    'address'?: string;
    'code'?: string;
    'createdAt'?: Date;
    'email'?: string;
    'id'?: number;
    'movements'?: Array<MovementDto>;
    'name'?: string;
    'phone'?: string;
    'products'?: Array<ProductDto>;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "movements",
            "baseName": "movements",
            "type": "Array<MovementDto>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "products",
            "baseName": "products",
            "type": "Array<ProductDto>"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return SupplierDto.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "CategoryDto": CategoryDto,
    "CustomerDto": CustomerDto,
    "MovementDetailDto": MovementDetailDto,
    "MovementDto": MovementDto,
    "MovementTypeDto": MovementTypeDto,
    "ProductDto": ProductDto,
    "ProductRepositoryDto": ProductRepositoryDto,
    "RepositoryDto": RepositoryDto,
    "ResponseCanonicalCategoryDto": ResponseCanonicalCategoryDto,
    "ResponseCanonicalCustomerDto": ResponseCanonicalCustomerDto,
    "ResponseCanonicalListCategoryDto": ResponseCanonicalListCategoryDto,
    "ResponseCanonicalListCustomerDto": ResponseCanonicalListCustomerDto,
    "ResponseCanonicalListMovementDetailDto": ResponseCanonicalListMovementDetailDto,
    "ResponseCanonicalListMovementDto": ResponseCanonicalListMovementDto,
    "ResponseCanonicalListMovementTypeDto": ResponseCanonicalListMovementTypeDto,
    "ResponseCanonicalListProductDto": ResponseCanonicalListProductDto,
    "ResponseCanonicalListProductRepositoryDto": ResponseCanonicalListProductRepositoryDto,
    "ResponseCanonicalListRepositoryDto": ResponseCanonicalListRepositoryDto,
    "ResponseCanonicalListSupplierDto": ResponseCanonicalListSupplierDto,
    "ResponseCanonicalMovementDetailDto": ResponseCanonicalMovementDetailDto,
    "ResponseCanonicalMovementDto": ResponseCanonicalMovementDto,
    "ResponseCanonicalMovementTypeDto": ResponseCanonicalMovementTypeDto,
    "ResponseCanonicalProductDto": ResponseCanonicalProductDto,
    "ResponseCanonicalProductRepositoryDto": ResponseCanonicalProductRepositoryDto,
    "ResponseCanonicalRepositoryDto": ResponseCanonicalRepositoryDto,
    "ResponseCanonicalSupplierDto": ResponseCanonicalSupplierDto,
    "ResponseCanonicalstring": ResponseCanonicalstring,
    "SupplierDto": SupplierDto,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum CategoryControllerApiApiKeys {
}

export class CategoryControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CategoryControllerApiApiKeys, value: string) {
        (this.authentications as any)[CategoryControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary createCategory
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public createCategoryUsingPOST (entityParam: CategoryDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalCategoryDto;  }> {
        const localVarPath = this.basePath + '/categories/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling createCategoryUsingPOST.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "CategoryDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary findCategory
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public findCategoryUsingGET (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalCategoryDto;  }> {
        const localVarPath = this.basePath + '/categories/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findCategoryUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary listCategories
     * @param skip 
     * @param limit 
     * @param from 
     * @param to 
     * @param name 
     * @param description 
     * @param parentCategoryId 
     * @param {*} [options] Override http request options.
     */
    public listCategoriesUsingGET (skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, parentCategoryId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalListCategoryDto;  }> {
        const localVarPath = this.basePath + '/categories/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (parentCategoryId !== undefined) {
            localVarQueryParameters['parentCategoryId'] = ObjectSerializer.serialize(parentCategoryId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalListCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalListCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary updateCategory
     * @param id id
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public updateCategoryUsingPUT (id: number, entityParam: CategoryDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalCategoryDto;  }> {
        const localVarPath = this.basePath + '/categories/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCategoryUsingPUT.');
        }

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling updateCategoryUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "CategoryDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalCategoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalCategoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerControllerApiApiKeys {
}

export class CustomerControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerControllerApiApiKeys, value: string) {
        (this.authentications as any)[CustomerControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary createCustomer
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public createCustomerUsingPOST (entityParam: CustomerDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalCustomerDto;  }> {
        const localVarPath = this.basePath + '/customers/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling createCustomerUsingPOST.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "CustomerDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalCustomerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalCustomerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary findCustomer
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public findCustomerUsingGET (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalCustomerDto;  }> {
        const localVarPath = this.basePath + '/customers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findCustomerUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalCustomerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalCustomerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary listCustomers
     * @param skip 
     * @param limit 
     * @param from 
     * @param to 
     * @param name 
     * @param movementId 
     * @param productId 
     * @param {*} [options] Override http request options.
     */
    public listCustomersUsingGET (skip?: number, limit?: number, from?: Date, to?: Date, name?: string, movementId?: number, productId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalListCustomerDto;  }> {
        const localVarPath = this.basePath + '/customers/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (movementId !== undefined) {
            localVarQueryParameters['movementId'] = ObjectSerializer.serialize(movementId, "number");
        }

        if (productId !== undefined) {
            localVarQueryParameters['productId'] = ObjectSerializer.serialize(productId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalListCustomerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalListCustomerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary updateCustomer
     * @param id id
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public updateCustomerUsingPUT (id: number, entityParam: CustomerDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalCustomerDto;  }> {
        const localVarPath = this.basePath + '/customers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCustomerUsingPUT.');
        }

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling updateCustomerUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "CustomerDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalCustomerDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalCustomerDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MovementControllerApiApiKeys {
}

export class MovementControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MovementControllerApiApiKeys, value: string) {
        (this.authentications as any)[MovementControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary findMovement
     * @param movementId movementId
     * @param {*} [options] Override http request options.
     */
    public findMovementUsingGET (movementId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementDto;  }> {
        const localVarPath = this.basePath + '/movements/{movementId}'
            .replace('{' + 'movementId' + '}', encodeURIComponent(String(movementId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'movementId' is not null or undefined
        if (movementId === null || movementId === undefined) {
            throw new Error('Required parameter movementId was null or undefined when calling findMovementUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalMovementDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary generateMovement
     * @param movementInfo movementInfo
     * @param {*} [options] Override http request options.
     */
    public generateMovementUsingPOST (movementInfo: MovementDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementDto;  }> {
        const localVarPath = this.basePath + '/movements/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'movementInfo' is not null or undefined
        if (movementInfo === null || movementInfo === undefined) {
            throw new Error('Required parameter movementInfo was null or undefined when calling generateMovementUsingPOST.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(movementInfo, "MovementDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalMovementDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary listMovements
     * @param movementDetailIds 
     * @param productIds 
     * @param movementTypeIds 
     * @param skip 
     * @param limit 
     * @param from 
     * @param to 
     * @param sourceRepositoryId 
     * @param targetRepositoryId 
     * @param customerId 
     * @param supplierId 
     * @param {*} [options] Override http request options.
     */
    public listMovementsUsingGET (movementDetailIds?: Array<number>, productIds?: Array<number>, movementTypeIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, sourceRepositoryId?: number, targetRepositoryId?: number, customerId?: number, supplierId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalListMovementDto;  }> {
        const localVarPath = this.basePath + '/movements/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (movementDetailIds !== undefined) {
            localVarQueryParameters['movementDetailIds'] = ObjectSerializer.serialize(movementDetailIds, "Array<number>");
        }

        if (productIds !== undefined) {
            localVarQueryParameters['productIds'] = ObjectSerializer.serialize(productIds, "Array<number>");
        }

        if (movementTypeIds !== undefined) {
            localVarQueryParameters['movementTypeIds'] = ObjectSerializer.serialize(movementTypeIds, "Array<number>");
        }

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (sourceRepositoryId !== undefined) {
            localVarQueryParameters['sourceRepositoryId'] = ObjectSerializer.serialize(sourceRepositoryId, "number");
        }

        if (targetRepositoryId !== undefined) {
            localVarQueryParameters['targetRepositoryId'] = ObjectSerializer.serialize(targetRepositoryId, "number");
        }

        if (customerId !== undefined) {
            localVarQueryParameters['customerId'] = ObjectSerializer.serialize(customerId, "number");
        }

        if (supplierId !== undefined) {
            localVarQueryParameters['supplierId'] = ObjectSerializer.serialize(supplierId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalListMovementDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalListMovementDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary rollbackMovement
     * @param parentMovementId parentMovementId
     * @param headerInfo headerInfo
     * @param {*} [options] Override http request options.
     */
    public rollbackMovementUsingPUT (parentMovementId: number, headerInfo: MovementDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementDto;  }> {
        const localVarPath = this.basePath + '/movements/{parentMovementId}'
            .replace('{' + 'parentMovementId' + '}', encodeURIComponent(String(parentMovementId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'parentMovementId' is not null or undefined
        if (parentMovementId === null || parentMovementId === undefined) {
            throw new Error('Required parameter parentMovementId was null or undefined when calling rollbackMovementUsingPUT.');
        }

        // verify required parameter 'headerInfo' is not null or undefined
        if (headerInfo === null || headerInfo === undefined) {
            throw new Error('Required parameter headerInfo was null or undefined when calling rollbackMovementUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(headerInfo, "MovementDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalMovementDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MovementDetailControllerApiApiKeys {
}

export class MovementDetailControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MovementDetailControllerApiApiKeys, value: string) {
        (this.authentications as any)[MovementDetailControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary createMovementDetail
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public createMovementDetailUsingPOST (entityParam: MovementDetailDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementDetailDto;  }> {
        const localVarPath = this.basePath + '/movement-details/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling createMovementDetailUsingPOST.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "MovementDetailDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementDetailDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalMovementDetailDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary findMovementDetail
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public findMovementDetailUsingGET (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementDetailDto;  }> {
        const localVarPath = this.basePath + '/movement-details/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findMovementDetailUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementDetailDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalMovementDetailDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary listMovementDetails
     * @param productIds 
     * @param skip 
     * @param limit 
     * @param from 
     * @param to 
     * @param movementId 
     * @param omitPositive 
     * @param omitNegative 
     * @param sourceRepositoryId 
     * @param targetRepositoryId 
     * @param {*} [options] Override http request options.
     */
    public listMovementDetailsUsingGET (productIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, movementId?: number, omitPositive?: boolean, omitNegative?: boolean, sourceRepositoryId?: number, targetRepositoryId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalListMovementDetailDto;  }> {
        const localVarPath = this.basePath + '/movement-details/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (productIds !== undefined) {
            localVarQueryParameters['productIds'] = ObjectSerializer.serialize(productIds, "Array<number>");
        }

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (movementId !== undefined) {
            localVarQueryParameters['movementId'] = ObjectSerializer.serialize(movementId, "number");
        }

        if (omitPositive !== undefined) {
            localVarQueryParameters['omitPositive'] = ObjectSerializer.serialize(omitPositive, "boolean");
        }

        if (omitNegative !== undefined) {
            localVarQueryParameters['omitNegative'] = ObjectSerializer.serialize(omitNegative, "boolean");
        }

        if (sourceRepositoryId !== undefined) {
            localVarQueryParameters['sourceRepositoryId'] = ObjectSerializer.serialize(sourceRepositoryId, "number");
        }

        if (targetRepositoryId !== undefined) {
            localVarQueryParameters['targetRepositoryId'] = ObjectSerializer.serialize(targetRepositoryId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalListMovementDetailDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalListMovementDetailDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary updateMovementDetail
     * @param id id
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public updateMovementDetailUsingPUT (id: number, entityParam: MovementDetailDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementDetailDto;  }> {
        const localVarPath = this.basePath + '/movement-details/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateMovementDetailUsingPUT.');
        }

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling updateMovementDetailUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "MovementDetailDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementDetailDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalMovementDetailDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MovementTypeControllerApiApiKeys {
}

export class MovementTypeControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MovementTypeControllerApiApiKeys, value: string) {
        (this.authentications as any)[MovementTypeControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary createMovementType
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public createMovementTypeUsingPOST (entityParam: MovementTypeDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementTypeDto;  }> {
        const localVarPath = this.basePath + '/movement-types/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling createMovementTypeUsingPOST.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "MovementTypeDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementTypeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalMovementTypeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary findMovementType
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public findMovementTypeUsingGET (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementTypeDto;  }> {
        const localVarPath = this.basePath + '/movement-types/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findMovementTypeUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementTypeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalMovementTypeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary listMovementTypes
     * @param skip 
     * @param limit 
     * @param from 
     * @param to 
     * @param name 
     * @param description 
     * @param sourceRepositoryId 
     * @param targetRepositoryId 
     * @param {*} [options] Override http request options.
     */
    public listMovementTypesUsingGET (skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, sourceRepositoryId?: number, targetRepositoryId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalListMovementTypeDto;  }> {
        const localVarPath = this.basePath + '/movement-types/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (sourceRepositoryId !== undefined) {
            localVarQueryParameters['sourceRepositoryId'] = ObjectSerializer.serialize(sourceRepositoryId, "number");
        }

        if (targetRepositoryId !== undefined) {
            localVarQueryParameters['targetRepositoryId'] = ObjectSerializer.serialize(targetRepositoryId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalListMovementTypeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalListMovementTypeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary updateMovementType
     * @param id id
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public updateMovementTypeUsingPUT (id: number, entityParam: MovementTypeDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementTypeDto;  }> {
        const localVarPath = this.basePath + '/movement-types/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateMovementTypeUsingPUT.');
        }

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling updateMovementTypeUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "MovementTypeDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalMovementTypeDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalMovementTypeDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProductControllerApiApiKeys {
}

export class ProductControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProductControllerApiApiKeys, value: string) {
        (this.authentications as any)[ProductControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary createProduct
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public createProductUsingPOST (entityParam: ProductDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalProductDto;  }> {
        const localVarPath = this.basePath + '/products/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling createProductUsingPOST.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "ProductDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalProductDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalProductDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary findProduct
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public findProductUsingGET (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalProductDto;  }> {
        const localVarPath = this.basePath + '/products/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findProductUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalProductDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalProductDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary listProducts
     * @param sourceSupplierIds 
     * @param customerIds 
     * @param supplierIds 
     * @param categoryIds 
     * @param skip 
     * @param limit 
     * @param from 
     * @param to 
     * @param name 
     * @param description 
     * @param {*} [options] Override http request options.
     */
    public listProductsUsingGET (sourceSupplierIds?: Array<number>, customerIds?: Array<number>, supplierIds?: Array<number>, categoryIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalListProductDto;  }> {
        const localVarPath = this.basePath + '/products/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (sourceSupplierIds !== undefined) {
            localVarQueryParameters['sourceSupplierIds'] = ObjectSerializer.serialize(sourceSupplierIds, "Array<number>");
        }

        if (customerIds !== undefined) {
            localVarQueryParameters['customerIds'] = ObjectSerializer.serialize(customerIds, "Array<number>");
        }

        if (supplierIds !== undefined) {
            localVarQueryParameters['supplierIds'] = ObjectSerializer.serialize(supplierIds, "Array<number>");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "Array<number>");
        }

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalListProductDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalListProductDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary updateProduct
     * @param id id
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public updateProductUsingPUT (id: number, entityParam: ProductDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalProductDto;  }> {
        const localVarPath = this.basePath + '/products/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateProductUsingPUT.');
        }

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling updateProductUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "ProductDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalProductDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalProductDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProductRepositoryControllerApiApiKeys {
}

export class ProductRepositoryControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProductRepositoryControllerApiApiKeys, value: string) {
        (this.authentications as any)[ProductRepositoryControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary createProductRepository
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public createProductRepositoryUsingPOST (entityParam: ProductRepositoryDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalProductRepositoryDto;  }> {
        const localVarPath = this.basePath + '/product-repositories/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling createProductRepositoryUsingPOST.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "ProductRepositoryDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalProductRepositoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalProductRepositoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary findProductRepository
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public findProductRepositoryUsingGET (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalProductRepositoryDto;  }> {
        const localVarPath = this.basePath + '/product-repositories/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findProductRepositoryUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalProductRepositoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalProductRepositoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary listProductRepositories
     * @param customerIds 
     * @param supplierIds 
     * @param sourceSupplierIds 
     * @param categoryIds 
     * @param repositoryIds 
     * @param productIds 
     * @param skip 
     * @param limit 
     * @param from 
     * @param to 
     * @param {*} [options] Override http request options.
     */
    public listProductRepositoriesUsingGET (customerIds?: Array<number>, supplierIds?: Array<number>, sourceSupplierIds?: Array<number>, categoryIds?: Array<number>, repositoryIds?: Array<number>, productIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalListProductRepositoryDto;  }> {
        const localVarPath = this.basePath + '/product-repositories/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (customerIds !== undefined) {
            localVarQueryParameters['customerIds'] = ObjectSerializer.serialize(customerIds, "Array<number>");
        }

        if (supplierIds !== undefined) {
            localVarQueryParameters['supplierIds'] = ObjectSerializer.serialize(supplierIds, "Array<number>");
        }

        if (sourceSupplierIds !== undefined) {
            localVarQueryParameters['sourceSupplierIds'] = ObjectSerializer.serialize(sourceSupplierIds, "Array<number>");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "Array<number>");
        }

        if (repositoryIds !== undefined) {
            localVarQueryParameters['repositoryIds'] = ObjectSerializer.serialize(repositoryIds, "Array<number>");
        }

        if (productIds !== undefined) {
            localVarQueryParameters['productIds'] = ObjectSerializer.serialize(productIds, "Array<number>");
        }

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalListProductRepositoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalListProductRepositoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary updateProductRepository
     * @param id id
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public updateProductRepositoryUsingPUT (id: number, entityParam: ProductRepositoryDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalProductRepositoryDto;  }> {
        const localVarPath = this.basePath + '/product-repositories/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateProductRepositoryUsingPUT.');
        }

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling updateProductRepositoryUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "ProductRepositoryDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalProductRepositoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalProductRepositoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RepositoryControllerApiApiKeys {
}

export class RepositoryControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RepositoryControllerApiApiKeys, value: string) {
        (this.authentications as any)[RepositoryControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary createRepository
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public createRepositoryUsingPOST (entityParam: RepositoryDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalRepositoryDto;  }> {
        const localVarPath = this.basePath + '/repositories/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling createRepositoryUsingPOST.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "RepositoryDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalRepositoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalRepositoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary findRepository
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public findRepositoryUsingGET (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalRepositoryDto;  }> {
        const localVarPath = this.basePath + '/repositories/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findRepositoryUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalRepositoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalRepositoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary listRepositories
     * @param customerIds 
     * @param supplierIds 
     * @param categoryIds 
     * @param productIds 
     * @param skip 
     * @param limit 
     * @param from 
     * @param to 
     * @param name 
     * @param description 
     * @param {*} [options] Override http request options.
     */
    public listRepositoriesUsingGET (customerIds?: Array<number>, supplierIds?: Array<number>, categoryIds?: Array<number>, productIds?: Array<number>, skip?: number, limit?: number, from?: Date, to?: Date, name?: string, description?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalListRepositoryDto;  }> {
        const localVarPath = this.basePath + '/repositories/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (customerIds !== undefined) {
            localVarQueryParameters['customerIds'] = ObjectSerializer.serialize(customerIds, "Array<number>");
        }

        if (supplierIds !== undefined) {
            localVarQueryParameters['supplierIds'] = ObjectSerializer.serialize(supplierIds, "Array<number>");
        }

        if (categoryIds !== undefined) {
            localVarQueryParameters['categoryIds'] = ObjectSerializer.serialize(categoryIds, "Array<number>");
        }

        if (productIds !== undefined) {
            localVarQueryParameters['productIds'] = ObjectSerializer.serialize(productIds, "Array<number>");
        }

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalListRepositoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalListRepositoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary updateRepository
     * @param id id
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public updateRepositoryUsingPUT (id: number, entityParam: RepositoryDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalRepositoryDto;  }> {
        const localVarPath = this.basePath + '/repositories/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateRepositoryUsingPUT.');
        }

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling updateRepositoryUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "RepositoryDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalRepositoryDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalRepositoryDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RootControllerApiApiKeys {
}

export class RootControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RootControllerApiApiKeys, value: string) {
        (this.authentications as any)[RootControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary heartBeat
     * @param {*} [options] Override http request options.
     */
    public heartBeatUsingGET (options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalstring;  }> {
        const localVarPath = this.basePath + '/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalstring;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalstring");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SupplierControllerApiApiKeys {
}

export class SupplierControllerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SupplierControllerApiApiKeys, value: string) {
        (this.authentications as any)[SupplierControllerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary createSupplier
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public createSupplierUsingPOST (entityParam: SupplierDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalSupplierDto;  }> {
        const localVarPath = this.basePath + '/suppliers/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling createSupplierUsingPOST.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "SupplierDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalSupplierDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalSupplierDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary findSupplier
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public findSupplierUsingGET (id: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalSupplierDto;  }> {
        const localVarPath = this.basePath + '/suppliers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findSupplierUsingGET.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalSupplierDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalSupplierDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary listSuppliers
     * @param skip 
     * @param limit 
     * @param from 
     * @param to 
     * @param name 
     * @param movementId 
     * @param productId 
     * @param {*} [options] Override http request options.
     */
    public listSuppliersUsingGET (skip?: number, limit?: number, from?: Date, to?: Date, name?: string, movementId?: number, productId?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalListSupplierDto;  }> {
        const localVarPath = this.basePath + '/suppliers/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "Date");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "Date");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (movementId !== undefined) {
            localVarQueryParameters['movementId'] = ObjectSerializer.serialize(movementId, "number");
        }

        if (productId !== undefined) {
            localVarQueryParameters['productId'] = ObjectSerializer.serialize(productId, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalListSupplierDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalListSupplierDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary updateSupplier
     * @param id id
     * @param entityParam entityParam
     * @param {*} [options] Override http request options.
     */
    public updateSupplierUsingPUT (id: number, entityParam: SupplierDto, options: any = {}) : Promise<{ response: http.ClientResponse; body: ResponseCanonicalSupplierDto;  }> {
        const localVarPath = this.basePath + '/suppliers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSupplierUsingPUT.');
        }

        // verify required parameter 'entityParam' is not null or undefined
        if (entityParam === null || entityParam === undefined) {
            throw new Error('Required parameter entityParam was null or undefined when calling updateSupplierUsingPUT.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entityParam, "SupplierDto")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ResponseCanonicalSupplierDto;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseCanonicalSupplierDto");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
